<!DOCTYPE html>  
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
  <title>2-Demo-Instructions</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style id="mkstylesheet">
body{-webkit-font-smoothing:antialiased;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;margin:30px 0 0;padding:0;background:#fff}#wrapper{padding:20px}li{font-size:110%}li li{font-size:100%}li p{font-size:100%;margin:.5em 0}h1{color:#000}h2{color:#111}h3{color:#111;margin:0}h4{color:#111}h5{color:#111}h6{font-size:1em;line-height:1.5em;margin:1.5em 0}body,p,td,div{color:#111;font-family:"Helvetica Neue",Helvetica,Arial,Verdana,sans-serif;word-wrap:break-word}a{color:#0d6ea1;text-decoration:none;-webkit-transition:color 0.2s ease-in-out;-moz-transition:color 0.2s ease-in-out;-o-transition:color 0.2s ease-in-out;-ms-transition:color 0.2s ease-in-out;transition:color 0.2s ease-in-out}a:hover{color:#3593d9}body{font-size:15px;line-height:21px;margin:0 auto}h1{font-size:37px;line-height:42px;margin-top:42px;margin-bottom:21px}h2{font-size:27px;line-height:42px;margin-top:42px;margin-bottom:21px}h3{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}h4{font-size:20px;line-height:21px;margin-top:21px;margin-bottom:21px}p,ul,ol,pre,table,blockquote{margin-top:21px;margin-bottom:21px}hr{border:1px solid;margin:-1px 0}ul ul,ol ol,ul ol,ol ul{margin-top:0;margin-bottom:0}b,strong,em,small,code{line-height:1}.footnote{color:#0d6ea1;font-size:.8em;vertical-align:super}abbr,acronym{border-bottom:1px dotted #aaa}#wrapper img{max-width:100%;height:auto}dd{font-size:1em;margin-bottom:1em}li>p:first-child{margin:0}ul ul,ul ol{margin-bottom:.4em}caption,col,colgroup,table,tbody,td,tfoot,th,thead,tr{border-spacing:0}table{border:1px solid rgba(0,0,0,0.25);border-collapse:collapse;display:table;empty-cells:hide;margin:-1px 0 1.3125em;padding:0;table-layout:fixed}caption{display:table-caption;font-weight:700}col{display:table-column}colgroup{display:table-column-group}tbody{display:table-row-group}tfoot{display:table-footer-group}thead{display:table-header-group}td,th{display:table-cell}tr{display:table-row}table th,table td{font-size:1.1em;line-height:1.3;padding:.5em 1em 0}table thead{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-bottom:1px solid rgba(0,0,0,0.2)}table tbody{background:rgba(0,0,0,0.05)}table tfoot{background:rgba(0,0,0,0.15);border:1px solid rgba(0,0,0,0.15);border-top:1px solid rgba(0,0,0,0.2)}figure{display:inline-block;overflow:hidden;position:relative;margin:1em 0 2em}figcaption{font-style:italic;text-align:center;background:white;color:#666}.poetry pre{display:block;font-family:Georgia,Garamond,serif !important;font-size:110% !important;font-style:italic;line-height:1.6em;margin-left:1em}.poetry pre code{font-family:Georgia,Garamond,serif !important;word-break:break-all;word-break:break-word;-webkit-hyphens:auto;-moz-hyphens:auto;hyphens:auto;white-space:pre-wrap}blockquote p{font-size:110%;font-style:italic;line-height:1.6em}sup,sub,a.footnote{font-size:1.4ex;height:0;line-height:1;position:relative;vertical-align:super}sub{vertical-align:sub;top:-1px}p,h5{font-size:1.1429em;line-height:1.3125em;margin:1.3125em 0}dt,th{font-weight:700}table tr:nth-child(odd),table th:nth-child(odd),table td:nth-child(odd){background:rgba(255,255,255,0.06)}table tr:nth-child(even),table td:nth-child(even){background:rgba(200,200,200,0.25)}@media print{img,table,figure{page-break-inside:avoid}#wrapper{background:#fff;color:#303030;padding:10px;position:relative;text-indent:0}}@media screen{.inverted{background:#252a2a}.inverted #wrapper{background:#252a2a;color:#eee}.inverted hr{border-color:#333f40 !important}.inverted p,.inverted td,.inverted li,.inverted h1,.inverted h2,.inverted h3,.inverted h4,.inverted h5,.inverted h6,.inverted th,.inverted .math,.inverted caption,.inverted dt,.inverted dd{color:#eee}.inverted pre{background:#ccc}.inverted pre code{color:#111}.inverted table{background:none}.inverted table tr:nth-child(odd),.inverted table td:nth-child(odd){background:none}.inverted a{color:#acd1d5}::selection{background:rgba(157,193,200,0.5)}h1::selection{background-color:rgba(45,156,208,0.3)}h2::selection{background-color:rgba(90,182,224,0.3)}h3::selection,h4::selection,h5::selection,h6::selection,li::selection,ol::selection{background-color:rgba(133,201,232,0.3)}code::selection{background-color:rgba(0,0,0,0.7);color:#eee}code span::selection{background-color:rgba(0,0,0,0.7) !important;color:#eee !important}a::selection{background-color:rgba(255,230,102,0.2)}.inverted a::selection{background-color:rgba(255,230,102,0.6)}td::selection,th::selection,caption::selection{background-color:rgba(180,237,95,0.5)}}

@media print{
#generated-toc-clone,#generated-toc{display:none!important}
}
#generated-toc-clone li.missing,#mkreplaced-toc li.missing{list-style-type:none!important}#generated-toc-clone li, #mkreplaced-toc li{list-style-type:upper-roman}#generated-toc-clone li li, #mkreplaced-toc li li{list-style-type:decimal}#generated-toc-clone li li li,#mkreplaced-toc li li li{list-style-type:decimal-leading-zero}#generated-toc-clone li li li li,#mkreplaced-toc li li li li{list-style-type:lower-greek}#generated-toc-clone li li li li li,#mkreplaced-toc li li li li li{list-style-type:disc}#generated-toc-clone li li li li li li,#mkreplaced-toc li li li li li li{list-style-type:square}
</style>

</head>
<body class="normal firstload">
  <div id="wrapper">
      <h1 id="202:swiftpart2:demoinstructions">202: Swift, Part 2: Demo Instructions</h1>

<p>In this demo, you will use a playground to experiment with generics, closures, and enums with associated values.</p>

<p>The steps here will be explained in the demo, but here are the raw steps in case you miss a step or get stuck.</p>

<h2 id="1closures">1) Closures</h2>

<p>Open the <strong>Demo.playground</strong> from the <strong>1-Starter</strong> folder.</p>

<p>Put the <code>countOccurrences()</code> function into the class. Remove the <code>array</code> parameter:</p>

<pre><code>class MyClass {  
  . . .

  func countOccurrences(value: Int) -&gt; String {  
    var count = 0  
    for element in array {  
      if element == value {  
        ++count  
      }
    }  
    return &quot;\(value) appears \(count) times&quot;  
  }
}
</code></pre>

<p>Call this method:</p>

<pre><code>myObject.countOccurrences(999)
</code></pre>

<p>It should give the same results as the function (&#8220;999 appears 4 times&#8221;).</p>

<p>Copy-paste the function parameters and body, but not the name, and assign it to a new variable:</p>

<pre><code>let c = (value: Int, array: [Int]) -&gt; String {  
  var count = 0  
  for element in array {  
    if element == value {  
      ++count  
    }
  }  
  return &quot;\(value) appears \(count) times&quot;  
}
</code></pre>

<p>This won&#8217;t work yet. You have to make a few syntax changes:</p>

<pre><code>let c: (value: Int, array: [Int]) -&gt; String = {
</code></pre>

<p>Add the closure&#8217;s parameters inside the curly brackets:</p>

<pre><code>(value: Int, array: [Int]) -&gt; String in
</code></pre>

<p>Remove the labels in the closure&#8217;s type:</p>

<pre><code>let c: (Int, [Int]) -&gt; String = { . . .
</code></pre>

<p>Call the closure:</p>

<pre><code>c(999, myArray)
</code></pre>

<p>It should give the same results as before (&#8220;999 appears 4 times&#8221;).</p>

<p>Add the following method to the class:</p>

<pre><code>func performClosure(value: Int, closure: (Int, [Int]) -&gt; String) -&gt; String {  
  return closure(value, array)  
}
</code></pre>

<p>Pass the <code>c</code> closure to this method:</p>

<pre><code>myObject.performClosure(999, closure: c)
</code></pre>

<p>Again you should get the same results.</p>

<p>Write a new inline closure:</p>

<pre><code>myObject.performClosure(100, closure: { (value: Int, array: [Int]) -&gt; String in  
  var newArray = [Int]()  
  for element in array {  
    newArray.append(element + value)  
  }
  return newArray.description  
})
</code></pre>

<p>Use trailing syntax to put the closure behind the method call:</p>

<pre><code>myObject.performClosure(100) { (value: Int, array: [Int]) -&gt; String in  
  var newArray = [Int]()  
  for element in array {  
    newArray.append(element + value)  
  }
  return newArray.description  
}
</code></pre>

<p>Simplify the closure&#8217;s parameters by removing the types, as well as the return type:</p>

<pre><code>{ value, array in . . .
</code></pre>

<p>Add a typealias (just above the class):</p>

<pre><code>typealias TransformArray = (Int, [Int]) -&gt; String
</code></pre>

<p>You can now write <code>performClosure()</code> as:</p>

<pre><code>func performClosure(value: Int, closure: TransformArray) -&gt; String {
</code></pre>

<p>And <code>c</code> as:</p>

<pre><code>let c: TransformArray = { . . .
</code></pre>

<h2 id="2closuresintic-tac-toe">2) Closures in Tic-Tac-Toe</h2>

<p>Change the closure to:</p>

<pre><code>{ action in self.reset() }
</code></pre>

<p>or even:</p>

<pre><code>{ _ in self.reset() }
</code></pre>

<p>To avoid capturing <code>self</code> as a strong reference, write:</p>

<pre><code>{ [weak self] _ in  
  if let strongSelf = self {  
    strongSelf.reset()  
  }
}
</code></pre>

<h2 id="3generics">3) Generics</h2>

<p>Make <code>countOccurrences()</code> generic:</p>

<pre><code>func countOccurrences&lt;T&gt;(value: T, array: [T]) -&gt; String {
</code></pre>

<p>Use a type restriction to limit this function to <code>Equatable</code> types:</p>

<pre><code>func countOccurrences&lt;T: Equatable&gt;(value: T, array: [T]) -&gt; String {
</code></pre>

<p>Test this function with an array of strings:</p>

<pre><code>let stringArray = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;B&quot;, &quot;D&quot;, &quot;E&quot;]  
countOccurrences(&quot;B&quot;, stringArray)
</code></pre>

<p>This should print &#8220;B appears 2 times&#8221;.</p>

<p>Replace <code>[Int]</code> with <code>Array&lt;Int&gt;</code>, and <code>[T]</code> with <code>Array&lt;T&gt;</code>.</p>

<p>Cmd-click on the word <code>Array</code> to see the definition in the Swift standard library.</p>

<h2 id="4enumswithassociatedvalues">4) Enums with Associated Values</h2>

<p>Give the labels in the <code>Player</code> enum values:</p>

<pre><code>enum Player: Int {  
  case X = 0  
  case O = 1  
}
</code></pre>

<p>Change these values to strings:</p>

<pre><code>enum Player: String {  
  case X = &quot;Player X&quot;  
  case O = &quot;Player O&quot;  
}
</code></pre>

<p>Add the following code to print out the raw value of an enum:</p>

<pre><code>let p = Player.X  
println(p.rawValue)
</code></pre>

<p>Use a <code>switch</code> to read the enum value:</p>

<pre><code>switch p {  
case .X:  
  println(&quot;Player is X&quot;)  
case .O:  
  println(&quot;Player is O&quot;)  
}
</code></pre>

<p>Remove the strings from the enum, and change the X case to:</p>

<pre><code>case X(username: String)
</code></pre>

<p>Change the <code>p</code> variable to:</p>

<pre><code>let p = Player.X(username: &quot;Steve&quot;)
</code></pre>

<p>Add another variable:</p>

<pre><code>let t = Player.X(username: &quot;Tim&quot;)
</code></pre>

<p>Modify the <code>switch</code> statement to print out the username:</p>

<pre><code>case .X(let username):  
  println(username)
</code></pre>

<p>Change the <code>switch</code> to:</p>

<pre><code>switch t {
</code></pre>

<p>Change the label inside the <code>switch</code> from <code>username</code> to <code>value</code>:</p>

<pre><code>case .X(let value):  
  println(value)
</code></pre>

<p>Associate another value with the X case:</p>

<pre><code>case X(username: String, country: String)
</code></pre>

<p>Change the creation of the two variables to include this additional value:</p>

<pre><code>let p = Player.X(username: &quot;Steve&quot;, country: &quot;USA&quot;)  
let t = Player.X(username: &quot;Tim&quot;, country: &quot;Belgium&quot;)
</code></pre>

<p>Inside the <code>switch</code>, change the case statement to:</p>

<pre><code>case .X(let username, let country):  
  println(country)
</code></pre>

<p>Rewrite it as:</p>

<pre><code>case let .X(username, country):
</code></pre>

<p>Replace the <code>username</code> label with the wildcard symbol:</p>

<pre><code>case let .X(_, country):
</code></pre>

<p>Cmd-click on the line <code>import Swift</code>. Search for &#8220;enum optional&#8221;.</p>

<p>Create two optional strings; the first uses syntactic sugar, the second uses the <code>Optional</code> enum directly:</p>

<pre><code>var s1: String? = &quot;Not nil&quot;  
var s2: Optional&lt;String&gt; = .Some(&quot;Not nil&quot;)
</code></pre>

<p>Verify that <code>s1</code> and <code>s2</code> are equal with:</p>

<pre><code>s1 == s2
</code></pre>

<h2 id="5thatsit">5) That&#8217;s it!</h2>

<p>Congrats, at this time you should have gained some insight into what closures, generics and enums are, and how to use them.</p>

<p>You are ready to move on to the lab.</p>
<!-- ##END MARKED WRAPPER## -->
    </div>
</body>
</html>